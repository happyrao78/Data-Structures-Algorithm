search in rotated sorted array where all elements are unique and no duplicates are present

brute force: using linear search but tc-o(n) and as it is mentioned in question sorted and search we will use binary search for this in order to reduce the search space and tc from o(n) to o(logn);

optimal approach:

int search(vector<int> &arr,int n,int k){
    int low=0,high=n-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(arr[mid]==k) return mid;
        ###### if left sorted ######
        if(arr[low]<=arr[mid]){
            if(arr[low]<=k && k<=arr[mid]){

                // eliminate the right half
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }

        right sorted
        else{
             if(arr[mid]<=k && k<=arr[high]){
                low=mid+1; // eliminate the left half of array
            }
            else{
                high=mid-1;
            }
        }
    }
    return -1;
}
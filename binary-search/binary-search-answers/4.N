MINIMUM DAYS TO MAKE BOUQUETS

BRUTE FORCE:
time complexity=o(n)+o(maxi-mini)+1;

bool possible(vector<int> arr,int days,int m, int k){
    int cnt=0,int nob=0;
    for(int i=;i<arr.size();i++){
        if(arr[i]<=day){
            cnt++;
        }
        else{
            nob+=(cnt/k);
            cnt=0;
        }
    }
    nob+=(cnt/k);
    return (nob >= m) ? true : false;
}
if(n < m*k) return -1;

for(i=mini;i<=maxi;i++){
    if(possible(arr,i,m,k)) return i;
    else return -1;
}
======================================================

optimal approach:
time complexity=o(n)+o(logn(maxi-mini))+1;
bool possible(vector<int> arr,int days,int m, int k){
    int cnt=0,int nob=0;
    for(int i=;i<arr.size();i++){
        if(arr[i]<=day){
            cnt++;
        }
        else{
            nob+=(cnt/k);
            cnt=0;
        }
    }
    nob+=(cnt/k);
    return (nob >= m) ? true : false;
}

int minDays(vector<int>& arr, int m, int k) {
    int val=m*1LL*k*2LL
    int mini= INT_MAX,maxi=INT_MIN;
    for(int i=0;i<arr.size();i++){
        mini=min(mini,arr[i]);
        maxi=max(maxi,arr[i]);
    }
    int low=mini,high=maxi;
    while(low<=high){
        int mid=(low+high)/2;
        if(possible(arr,mid,m,k)){
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return low;
}
